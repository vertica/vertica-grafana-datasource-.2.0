{"version":3,"sources":["../../src/rules/validTypes.js"],"names":["asExpression","jsdoc","report","utils","context","settings","allowEmptyNamepaths","checkSeesForNamepaths","options","mode","tags","forEach","tag","validNamepathParsing","namepath","tagName","handled","includes","endChar","slice","startChar","charAt","validTypeParsing","type","hasTypePosition","tagMightHaveTypePosition","Boolean","mustHaveTypePosition","tagMustHaveTypePosition","hasNameOrNamepathPosition","tagMustHaveNamePosition","tagMightHaveNamePosition","name","mustHaveNameOrNamepathPosition","hasEither","tagMightHaveEitherTypeOrNamePosition","mustHaveEither","tagMustHaveEitherTypeOrNamePosition","skip","thisNamepath","description","replace","test","thatNamepath","iterateAllJsdocs","meta","docs","schema","additionalProperies","properties","default"],"mappings":"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","sourcesContent":["import {parse} from 'jsdoctypeparser';\nimport iterateJsdoc from '../iterateJsdoc';\n\nconst asExpression = /as\\s+/u;\n\nexport default iterateJsdoc(({\n  jsdoc,\n  report,\n  utils,\n  context,\n  settings,\n}) => {\n  const {\n    allowEmptyNamepaths = true,\n    checkSeesForNamepaths = false,\n  } = context.options[0] || {};\n  const {mode} = settings;\n  if (!jsdoc.tags) {\n    return;\n  }\n  // eslint-disable-next-line complexity\n  jsdoc.tags.forEach((tag) => {\n    const validNamepathParsing = function (namepath, tagName) {\n      try {\n        parse(namepath, {mode});\n      } catch {\n        let handled = false;\n\n        if (tagName) {\n          if (['memberof', 'memberof!'].includes(tagName)) {\n            const endChar = namepath.slice(-1);\n            if (['#', '.', '~'].includes(endChar)) {\n              try {\n                parse(namepath.slice(0, -1), {mode});\n                handled = true;\n              } catch {\n                // Use the original error for including the whole type\n              }\n            }\n          } else if (tagName === 'borrows') {\n            const startChar = namepath.charAt();\n            if (['#', '.', '~'].includes(startChar)) {\n              try {\n                parse(namepath.slice(1), {mode});\n                handled = true;\n              } catch {\n                // Use the original error for including the whole type\n              }\n            }\n          }\n        }\n\n        if (!handled) {\n          report(`Syntax error in namepath: ${namepath}`, null, tag);\n\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    const validTypeParsing = function (type) {\n      try {\n        parse(type, {mode});\n      } catch {\n        report(`Syntax error in type: ${type}`, null, tag);\n\n        return false;\n      }\n\n      return true;\n    };\n\n    const hasTypePosition = utils.tagMightHaveTypePosition(tag.tag) && Boolean(tag.type);\n    const mustHaveTypePosition = utils.tagMustHaveTypePosition(tag.tag);\n\n    const hasNameOrNamepathPosition = (\n      utils.tagMustHaveNamePosition(tag.tag) ||\n      utils.tagMightHaveNamePosition(tag.tag)\n    ) && Boolean(tag.name) && !(tag.tag === 'see' && !checkSeesForNamepaths);\n\n    // Don't handle `param` here though it does require name as handled by\n    //  `require-param-name` and `require-property-name`\n    const mustHaveNameOrNamepathPosition = ![\n      'param', 'arg', 'argument',\n      'property', 'prop',\n    ].includes(tag.tag) &&\n      utils.tagMustHaveNamePosition(tag.tag) && !allowEmptyNamepaths;\n\n    const hasEither = utils.tagMightHaveEitherTypeOrNamePosition(tag.tag) && (hasTypePosition || hasNameOrNamepathPosition);\n    const mustHaveEither = utils.tagMustHaveEitherTypeOrNamePosition(tag.tag);\n\n    let skip;\n    switch (tag.tag) {\n    case 'borrows': {\n      const thisNamepath = tag.description.replace(asExpression, '');\n\n      if (!asExpression.test(tag.description) || !thisNamepath) {\n        report(`@borrows must have an \"as\" expression. Found \"${tag.description}\"`, null, tag);\n\n        return;\n      }\n\n      if (validNamepathParsing(thisNamepath, 'borrows')) {\n        const thatNamepath = tag.name;\n\n        validNamepathParsing(thatNamepath);\n      }\n      break;\n    }\n    case 'extends':\n    case 'package': case 'private': case 'protected': case 'public': case 'static': {\n      if (mode !== 'closure' && mode !== 'permissive' && tag.type) {\n        report(`@${tag.tag} should not have a bracketed type in \"${mode}\" mode.`, null, tag);\n        break;\n      }\n      skip = true;\n    }\n\n    // Fallthrough\n    case 'typedef': {\n      if (!skip && mode !== 'closure' && mode !== 'permissive' && !tag.name) {\n        report(`@typedef must have a name in \"${mode}\" mode.`, null, tag);\n        break;\n      }\n      skip = true;\n    }\n\n    // Fallthrough\n    case 'interface': {\n      if (!skip && mode === 'closure' && tag.name) {\n        report('@interface should not have a name in \"closure\" mode.', null, tag);\n        break;\n      }\n    }\n\n    // Fallthrough\n    default: {\n      if (mustHaveEither && !hasEither && !mustHaveTypePosition) {\n        report(`Tag @${tag.tag} must have either a type or namepath`, null, tag);\n\n        return;\n      }\n      if (hasTypePosition) {\n        validTypeParsing(tag.type);\n      } else if (mustHaveTypePosition) {\n        report(`Tag @${tag.tag} must have a type`, null, tag);\n      }\n\n      if (hasNameOrNamepathPosition) {\n        validNamepathParsing(tag.name, tag.tag);\n      } else if (mustHaveNameOrNamepathPosition) {\n        report(`Tag @${tag.tag} must have a name/namepath`, null, tag);\n      }\n    }\n    }\n  });\n}, {\n  iterateAllJsdocs: true,\n  meta: {\n    docs: {\n      description: 'Requires all types to be valid JSDoc or Closure compiler types without syntax errors.',\n    },\n    schema: [\n      {\n        additionalProperies: false,\n        properties: {\n          allowEmptyNamepaths: {\n            default: true,\n            type: 'boolean',\n          },\n          checkSeesForNamepaths: {\n            default: false,\n            type: 'boolean',\n          },\n        },\n        type: 'object',\n      },\n    ],\n    type: 'suggestion',\n  },\n});\n"],"file":"validTypes.js"}