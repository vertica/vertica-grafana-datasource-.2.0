"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _DOMMatrix = _interopRequireDefault(require("./DOMMatrix"));

var _CanvasPattern = _interopRequireDefault(require("./CanvasPattern"));

var _parseColor = _interopRequireDefault(require("parse-color"));

var _cssfontparser = _interopRequireDefault(require("cssfontparser"));

var _TextMetrics = _interopRequireDefault(require("./TextMetrics"));

var _createCanvasEvent = _interopRequireDefault(require("../mock/createCanvasEvent"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function parseCSSColor(value) {
  var result = (0, _parseColor["default"])(value);

  if (result.rgba && result.rgba[3] !== 1) {
    return 'rgba(' + result.rgba.join(', ') + ')';
  }

  if (result.hex) {
    var hex = result.hex; // shorthand #ABC

    if (hex[1] === hex[2] && hex[3] === hex[4] && hex[5] === hex[6]) {
      return '#' + hex[1] + hex[3] + hex[5];
    }

    return result.hex;
  }

  return void 0;
}

var testFuncs = ['setLineDash', 'getLineDash', 'setTransform', 'getTransform', 'getImageData', 'save', 'restore', 'createPattern', 'createRadialGradient', 'addHitRegion', 'arc', 'arcTo', 'beginPath', 'clip', 'closePath', 'scale', 'stroke', 'clearHitRegions', 'clearRect', 'fillRect', 'strokeRect', 'rect', 'resetTransform', 'translate', 'moveTo', 'lineTo', 'bezierCurveTo', 'createLinearGradient', 'ellipse', 'measureText', 'rotate', 'drawImage', 'drawFocusIfNeeded', 'isPointInPath', 'isPointInStroke', 'putImageData', 'strokeText', 'fillText', 'quadraticCurveTo', 'removeHitRegion', 'fill', 'transform', 'scrollPathIntoView', 'createImageData'];
var compositeOperations = ['source-over', 'source-in', 'source-out', 'source-atop', 'destination-over', 'destination-in', 'destination-out', 'destination-atop', 'lighter', 'copy', 'xor', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'];

function getTransformSlice(ctx) {
  return ctx._transformStack[ctx._stackIndex].slice();
}

var CanvasRenderingContext2D =
/*#__PURE__*/
function () {
  _createClass(CanvasRenderingContext2D, [{
    key: "__getDrawCalls",

    /**
     * Every time a function call would result in a drawing operation, it should be added to this array.
     * This goes for only draw call functions.
     */
    value: function __getDrawCalls() {
      return this._drawCalls.slice();
    }
    /**
     * Every time a function call results in something that would have modified the state of the context,
     * an event is added to this array. This goes for every property set, and draw call.
     */

  }, {
    key: "__getEvents",
    value: function __getEvents() {
      return this._events.slice();
    }
    /**
     * This array keeps track of the current path, so that fill and stroke operations can store the
     * path.
     */

  }, {
    key: "__getPath",
    value: function __getPath() {
      return this._path.slice();
    }
  }]);

  function CanvasRenderingContext2D(canvas) {
    var _this = this;

    _classCallCheck(this, CanvasRenderingContext2D);

    _defineProperty(this, "_drawCalls", []);

    _defineProperty(this, "_events", []);

    _defineProperty(this, "_path", [(0, _createCanvasEvent["default"])('beginPath', [1, 0, 0, 1, 0, 0], {})]);

    _defineProperty(this, "_directionStack", ['inherit']);

    _defineProperty(this, "_fillStyleStack", ['#000']);

    _defineProperty(this, "_filterStack", ['none']);

    _defineProperty(this, "_fontStack", ['10px sans-serif']);

    _defineProperty(this, "_globalAlphaStack", [1.0]);

    _defineProperty(this, "_globalCompositeOperationStack", ['source-over']);

    _defineProperty(this, "_imageSmoothingEnabledStack", [true]);

    _defineProperty(this, "_imageSmoothingQualityStack", ['low']);

    _defineProperty(this, "_lineCapStack", ['butt']);

    _defineProperty(this, "_lineDashOffsetStack", [0]);

    _defineProperty(this, "_lineDashStack", [[]]);

    _defineProperty(this, "_lineJoinStack", ['miter']);

    _defineProperty(this, "_lineWidthStack", [1]);

    _defineProperty(this, "_miterLimitStack", [10]);

    _defineProperty(this, "_shadowBlurStack", [0]);

    _defineProperty(this, "_shadowColorStack", ['rgba(0, 0, 0, 0)']);

    _defineProperty(this, "_shadowOffsetXStack", [0]);

    _defineProperty(this, "_shadowOffsetYStack", [0]);

    _defineProperty(this, "_stackIndex", 0);

    _defineProperty(this, "_strokeStyleStack", ['#000']);

    _defineProperty(this, "_textAlignStack", ['start']);

    _defineProperty(this, "_textBaselineStack", ['alphabetic']);

    _defineProperty(this, "_transformStack", [[1, 0, 0, 1, 0, 0]]);

    testFuncs.forEach(function (key) {
      _this[key] = jest.fn(CanvasRenderingContext2D.prototype[key].bind(_this));
    });
    this._canvas = canvas;
  }

  _createClass(CanvasRenderingContext2D, [{
    key: "addHitRegion",
    value: function addHitRegion() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var path = options.path,
          fillRule = options.fillRule,
          id = options.id,
          parentID = options.parentID,
          cursor = options.cursor,
          control = options.control,
          label = options.label,
          role = options.role;
      if (!path && !id) throw new DOMException('ConstraintError', 'Failed to execute \'addHitRegion\' on \'' + this.constructor.name + '\': Both id and control are null.');
      if (fillRule && fillRule !== 'evenodd' && fillRule !== 'nonzero') throw new TypeError('Failed to execute \'addHitRegion\' on \'' + this.constructor.name + '\': The provided value \'' + fillRule + '\' is not a valid enum value of type CanvasFillRule.');

      this._events.push((0, _createCanvasEvent["default"])('addHitRegion', getTransformSlice(this), {
        path: path,
        fillRule: fillRule,
        id: id,
        parentID: parentID,
        cursor: cursor,
        control: control,
        label: label,
        role: role
      }));
    }
  }, {
    key: "arc",
    value: function arc(x, y, radius, startAngle, endAngle) {
      var anticlockwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
      if (arguments.length < 5) throw new TypeError('Failed to execute \'arc\' on \'' + this.constructor.name + '\': 5 arguments required, but only ' + arguments.length + ' present.');
      var xResult = Number(x);
      var yResult = Number(y);
      var radiusResult = Number(radius);
      var startAngleResult = Number(startAngle);
      var endAngleResult = Number(endAngle);
      var anticlockwiseResult = Boolean(anticlockwise); // quick is finite check

      if (!Number.isFinite(xResult + yResult + radiusResult + startAngleResult + endAngleResult)) return;
      if (Number(radius) < 0) throw new DOMException('IndexSizeError', 'Failed to execute \'arc\' on \'' + this.constructor.name + '\': The radius provided (' + radius + ') is negative.');
      var event = (0, _createCanvasEvent["default"])('arc', getTransformSlice(this), {
        x: xResult,
        y: yResult,
        radius: radiusResult,
        startAngle: startAngleResult,
        endAngle: endAngleResult,
        anticlockwise: anticlockwiseResult
      });

      this._path.push(event);

      this._events.push(event);
    }
  }, {
    key: "arcTo",
    value: function arcTo(cpx1, cpy1, cpx2, cpy2, radius) {
      if (arguments.length < 5) throw new DOMException('IndexSizeError', 'Failed to execute \'arcTo\' on \'' + this.constructor.name + '\': 5 arguments required, but only ' + arguments.length + ' present.');
      var cpx1Result = Number(cpx1);
      var cpy1Result = Number(cpy1);
      var cpx2Result = Number(cpx2);
      var cpy2Result = Number(cpy2);
      var radiusResult = Number(radius);
      if (!Number.isFinite(cpx1Result + cpx2Result + cpy1Result + cpy2Result + radiusResult)) return;
      if (radiusResult < 0) throw new TypeError('Failed to execute \'arcTo\' on \'' + this.constructor.name + '\': The radius provided (' + radius + ') is negative.');
      var event = (0, _createCanvasEvent["default"])('arcTo', getTransformSlice(this), {
        cpx1: cpx1Result,
        cpy1: cpy1Result,
        cpx2: cpx2Result,
        cpy2: cpy2Result,
        radius: radiusResult
      });

      this._path.push(event);

      this._events.push(event);
    }
  }, {
    key: "beginPath",
    value: function beginPath() {
      var event = (0, _createCanvasEvent["default"])('beginPath', getTransformSlice(this), {});
      this._path = [event];

      this._events.push(event);
    }
  }, {
    key: "bezierCurveTo",
    value: function bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y) {
      if (arguments.length < 6) throw new TypeError('Failed to execute \'bezierCurveTo\' on \'' + this.constructor.name + '\': 6 arguments required, but only ' + arguments.length + ' present.');
      var cpx1Result = Number(cpx1);
      var cpy1Result = Number(cpy1);
      var cpx2Result = Number(cpx2);
      var cpy2Result = Number(cpy2);
      var xResult = Number(x);
      var yResult = Number(y);
      if (!Number.isFinite(cpx1Result + cpy1Result + cpx2Result + cpy2Result + xResult + yResult)) return;
      var event = (0, _createCanvasEvent["default"])('bezierCurveTo', getTransformSlice(this), {
        cpx1: cpx1,
        cpy1: cpy1,
        cpx2: cpx2,
        cpy2: cpy2,
        x: x,
        y: y
      });

      this._path.push(event);

      this._events.push(event);
    }
  }, {
    key: "clearHitRegions",
    value: function clearHitRegions() {
      var event = (0, _createCanvasEvent["default"])('clearHitRegions', getTransformSlice(this), {});

      this._events.push(event);
    }
  }, {
    key: "clearRect",
    value: function clearRect(x, y, width, height) {
      if (arguments.length < 4) throw new TypeError('Failed to execute \'clearRect\' on \'' + this.constructor.name + '\': 4 arguments required, but only ' + arguments.length + ' present.');
      var xResult = Number(x);
      var yResult = Number(y);
      var widthResult = Number(width);
      var heightResult = Number(height);
      if (!Number.isFinite(x + y + width + height)) return;
      var event = (0, _createCanvasEvent["default"])('clearRect', getTransformSlice(this), {
        x: xResult,
        y: yResult,
        width: widthResult,
        height: heightResult
      });

      this._events.push(event);

      this._drawCalls.push(event);
    }
  }, {
    key: "clip",
    value: function clip(path, fillRule) {
      if (arguments.length === 0) {
        fillRule = 'nonzero';
        path = this._path.slice();
      } else {
        if (arguments.length === 1) fillRule = 'nonzero';

        if (path instanceof Path2D) {
          fillRule = String(fillRule);
          if (fillRule !== 'nonzero' && fillRule !== 'evenodd') throw new TypeError('Failed to execute \'clip\' on \'' + this.constructor.name + '\': The provided value \'' + fillRule + '\' is not a valid enum value of type CanvasFillRule.');
          path = path._path.slice();
        } else {
          fillRule = String(path);
          if (fillRule !== 'nonzero' && fillRule !== 'evenodd') throw new TypeError('Failed to execute \'clip\' on \'' + this.constructor.name + '\': The provided value \'' + fillRule + '\' is not a valid enum value of type CanvasFillRule.');
          path = this._path.slice();
        }
      }

      var event = (0, _createCanvasEvent["default"])('clip', getTransformSlice(this), {
        path: path,
        fillRule: fillRule
      });

      this._path.push(event);

      this._events.push(event);
    }
  }, {
    key: "closePath",
    value: function closePath() {
      var event = (0, _createCanvasEvent["default"])('closePath', getTransformSlice(this), {});

      this._events.push(event);

      this._path.push(event);
    }
  }, {
    key: "createImageData",
    value: function createImageData(width, height) {
      if (arguments.length < 1) throw new TypeError('Failed to execute \'createImageData\' on \'' + this.constructor.name + '\': 1 argument required, but only 0 present.');else if (arguments.length === 1) {
        if (!(width instanceof ImageData)) throw new TypeError('Failed to execute \'createImageData\' on \'' + this.constructor.name + '\': parameter 1 is not of type \'ImageData\'.');
        var result = new ImageData(width.width, width.height);
        result.data.set(width.data);
        var event = (0, _createCanvasEvent["default"])('createImageData', getTransformSlice(this), {
          width: width.width,
          height: width.height
        });

        this._events.push(event);

        return result;
      } else {
        width = Math.abs(Number(width));
        height = Math.abs(Number(height));
        if (!Number.isFinite(width) || width === 0) throw new TypeError('Failed to execute \'createImageData\' on \'' + this.constructor.name + '\': The source width is 0.');
        if (!Number.isFinite(height) || height === 0) throw new TypeError('Failed to execute \'createImageData\' on \'' + this.constructor.name + '\': The source height is 0.');

        var _event = (0, _createCanvasEvent["default"])('createImageData', getTransformSlice(this), {
          width: width,
          height: height
        });

        this._events.push(_event);

        return new ImageData(width, height);
      }
    }
  }, {
    key: "createLinearGradient",
    value: function createLinearGradient(x0, y0, x1, y1) {
      if (arguments.length < 4) throw new TypeError('Failed to execute \'createLinearGradient\' on \'' + this.constructor.name + '\': 4 arguments required, but only ' + arguments.length + ' present.');
      var x0Result = Number(x0);
      var y0Result = Number(y0);
      var x1Result = Number(x1);
      var y1Result = Number(y1);
      if (!Number.isFinite(x0Result + y0Result + x1Result + y1Result)) throw new TypeError('Failed to execute \'createLinearGradient\' on \'' + this.constructor.name + '\': The provided double value is non-finite.');
      var event = (0, _createCanvasEvent["default"])('createLinearGradient', getTransformSlice(this), {
        x0: x0Result,
        y0: y0Result,
        x1: x1Result,
        y1: y1Result
      });

      this._events.push(event);

      return new CanvasGradient();
    }
  }, {
    key: "createPattern",
    value: function createPattern(image, type) {
      if (arguments.length === 1) throw new TypeError('Failed to execute \'createPattern\' on \'' + this.constructor.name + '\': 2 arguments required, but only 1 present.');
      if (type === null) type = 'repeat';
      if (type === '') type = 'repeat';

      if (type === 'repeat' || type === 'repeat-x' || type === 'repeat-y' || type === 'no-repeat') {
        var event = (0, _createCanvasEvent["default"])('createPattern', getTransformSlice(this), {
          image: image,
          type: type
        });

        if (image instanceof ImageBitmap) {
          if (image._closed) throw new DOMException('InvalidStateError', 'Failed to execute \'createPattern\' on \'CanvasRenderingContext2D\': The image source is detached.');

          this._events.push(event);

          return new _CanvasPattern["default"]();
        }

        if (image instanceof HTMLImageElement) {
          this._events.push(event);

          return new _CanvasPattern["default"]();
        }

        if (image instanceof HTMLVideoElement) {
          this._events.push(event);

          return new _CanvasPattern["default"]();
        }

        if (image instanceof HTMLCanvasElement) {
          this._events.push(event);

          return new _CanvasPattern["default"]();
        }
      } else {
        throw new TypeError('Failed to execute \'createPattern\' on \'' + this.constructor.name + '\': The provided type (\'' + type + '\') is not one of \'repeat\', \'no-repeat\', \'repeat-x\', or \'repeat-y\'.');
      }

      throw new TypeError('Failed to execute \'createPattern\' on \'' + this.constructor.name + '\': The provided value is not of type \'(CSSImageValue or HTMLImageElement or SVGImageElement or HTMLVideoElement or HTMLCanvasElement or ImageBitmap or OffscreenCanvas)\'');
    }
  }, {
    key: "createRadialGradient",
    value: function createRadialGradient(x0, y0, r0, x1, y1, r1) {
      if (arguments.length < 6) throw new TypeError('Failed to execute \'createRadialGradient\' on \'' + this.constructor.name + '\': 6 arguments required, but only ' + arguments.length + ' present.');
      var x0Result = Number(x0);
      var y0Result = Number(y0);
      var r0Result = Number(r0);
      var x1Result = Number(x1);
      var y1Result = Number(y1);
      var r1Result = Number(r1);
      if (!Number.isFinite(x0Result + y0Result + r0Result + x1Result + y1Result + r1Result)) throw new TypeError('Failed to execute \'createRadialGradient\' on \'' + this.constructor.name + '\': The provided double value is non-finite.');
      if (r0Result < 0) throw new DOMException('IndexSizeError', 'Failed to execute \'createRadialGradient\' on \'' + this.constructor.name + '\': The r0 provided is less than 0.');
      if (r1Result < 0) throw new DOMException('IndexSizeError', 'Failed to execute \'createRadialGradient\' on \'' + this.constructor.name + '\': The r1 provided is less than 0.');
      var event = (0, _createCanvasEvent["default"])('createRadialGradient', getTransformSlice(this), {
        x0: x0Result,
        y0: y0Result,
        r0: r0Result,
        x1: x1Result,
        y1: y1Result,
        r1: r1Result
      });

      this._events.push(event);

      return new CanvasGradient();
    }
  }, {
    key: "drawFocusIfNeeded",
    value: function drawFocusIfNeeded(path, element) {
      if (arguments.length === 0) throw new TypeError('Failed to execute \'drawFocusIfNeeded\' on \'' + this.constructor.name + '\': 1 argument required, but only 0 present.');
      if (arguments.length === 2 && !(path instanceof Path2D)) throw new TypeError('Failed to execute \'drawFocusIfNeeded\' on \'' + this.constructor.name + '\': parameter 1 is not of type \'Path2D\'.');

      if (arguments.length === 1) {
        element = path;
        path = null;
      }

      if (!(element instanceof Element)) throw new TypeError('Failed to execute \'drawFocusIfNeeded\' on \'' + this.constructor.name + '\': parameter ' + arguments.length + ' is not of type \'Element\'.');
      var event = (0, _createCanvasEvent["default"])('drawFocusIfNeeded', getTransformSlice(this), {
        path: path ? path._path : null,
        element: element
      });

      this._events.push(event);
    }
  }, {
    key: "drawImage",
    value: function drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
      if (arguments.length < 3) throw new TypeError('Failed to execute \'drawImage\' on \'' + this.constructor.name + '\': 3 arguments required, but only ' + arguments.length + ' present.');
      if (arguments.length === 4 || arguments.length > 5 && arguments.length < 9) throw new TypeError('Failed to execute \'drawImage\' on \'' + this.constructor.name + '\': Valid arities are: [3, 5, 9], but 4 arguments provided.');
      var valid = false;
      if (img instanceof HTMLImageElement) valid = true;
      ;

      if (img instanceof ImageBitmap) {
        if (img._closed) throw new DOMException('InvalidStateError', 'DOMException: Failed to execute \'drawImage\' on \'CanvasRenderingContext2D\': The image source is detached.');
        valid = true;
      }

      if (img instanceof HTMLVideoElement) valid = true;
      if (img instanceof HTMLCanvasElement) valid = true;
      if (!valid) throw new TypeError('Failed to execute \'drawImage\' on \'' + this.constructor.name + '\': The provided value is not of type \'(CSSImageValue or HTMLImageElement or SVGImageElement or HTMLVideoElement or HTMLCanvasElement or ImageBitmap or OffscreenCanvas)\'');
      var sxResult = Number(sx);
      var syResult = Number(sy);
      var sWidthResult = Number(sWidth);
      var sHeightResult = Number(sHeight);
      var dxResult = Number(dx);
      var dyResult = Number(dy);
      var dWidthResult = Number(dWidth);
      var dHeightResult = Number(dHeight);

      if (arguments.length === 3) {
        if (!Number.isFinite(sxResult + syResult)) return;
        sx = 0;
        sy = 0;
        sWidth = img.width;
        sHeight = img.height;
        dx = sxResult;
        dy = syResult;
        dWidth = img.width;
        dHeight = img.height;
      } else if (arguments.length === 5) {
        if (!Number.isFinite(sxResult + syResult + sWidthResult + sHeightResult)) return;
        sx = 0;
        sy = 0;
        sWidth = img.width;
        sHeight = img.height;
        dx = sxResult;
        dy = syResult;
        dWidth = sWidth;
        dHeight = sHeight;
      } else {
        if (!Number.isFinite(sx + sy + sWidth + sHeight + dx + dy + dWidth + dHeight)) return;
        sx = sxResult;
        sy = syResult;
        sWidth = sWidthResult;
        sHeight = sHeightResult;
        dx = dxResult;
        dy = dyResult;
        dWidth = dWidthResult;
        dHeight = dHeightResult;
      }

      var event = (0, _createCanvasEvent["default"])('drawImage', getTransformSlice(this), {
        img: img,
        sx: sx,
        sy: sy,
        sWidth: sWidth,
        sHeight: sHeight,
        dx: dx,
        dy: dy,
        dWidth: dWidth,
        dHeight: dHeight
      });

      this._events.push(event);

      this._drawCalls.push(event);
    }
  }, {
    key: "ellipse",
    value: function ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle) {
      var anticlockwise = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
      if (arguments.length < 7) throw new TypeError('Failed to execute \'ellipse\' on \'' + this.constructor.name + '\': 6 arguments required, but only ' + arguments.length + ' present.');
      var xResult = Number(x);
      var yResult = Number(y);
      var radiusXResult = Number(radiusX);
      var radiusYResult = Number(radiusY);
      var rotationResult = Number(rotation);
      var startAngleResult = Number(startAngle);
      var endAngleResult = Number(endAngle);
      var anticlockwiseResult = Boolean(anticlockwise);
      if (!Number.isFinite(xResult + yResult + radiusXResult + radiusYResult + rotationResult + startAngleResult + endAngleResult)) return;
      if (Number(radiusX) < 0) throw new DOMException('IndexSizeError', 'Failed to execute \'ellipse\' on \'' + this.constructor.name + '\': The major-axis radius provided (' + radiusX + ') is negative.');
      if (Number(radiusY) < 0) throw new DOMException('IndexSizeError', 'Failed to execute \'ellipse\' on \'' + this.constructor.name + '\': The minor-axis radius provided (' + radiusY + ') is negative.');
      var event = (0, _createCanvasEvent["default"])('ellipse', getTransformSlice(this), {
        x: xResult,
        y: yResult,
        radiusX: radiusXResult,
        radiusY: radiusYResult,
        rotation: rotationResult,
        startAngle: startAngleResult,
        endAngle: endAngleResult,
        anticlockwise: anticlockwiseResult
      });

      this._path.push(event);

      this._events.push(event);
    }
  }, {
    key: "fill",
    value: function fill(path, fillRule) {
      if (arguments.length === 0) {
        fillRule = 'nonzero';
        path = this._path.slice();
      } else {
        if (arguments.length === 1) fillRule = 'nonzero';

        if (path instanceof Path2D) {
          fillRule = String(fillRule);
          if (fillRule !== 'nonzero' && fillRule !== 'evenodd') throw new TypeError('Failed to execute \'clip\' on \'' + this.constructor.name + '\': The provided value \'' + fillRule + '\' is not a valid enum value of type CanvasFillRule.');
          path = path._path.slice();
        } else {
          fillRule = String(path);
          if (fillRule !== 'nonzero' && fillRule !== 'evenodd') throw new TypeError('Failed to execute \'clip\' on \'' + this.constructor.name + '\': The provided value \'' + fillRule + '\' is not a valid enum value of type CanvasFillRule.');
          path = this._path.slice();
        }
      }

      var event = (0, _createCanvasEvent["default"])('fill', getTransformSlice(this), {
        path: path,
        fillRule: fillRule
      });

      this._events.push(event);

      this._drawCalls.push(event);
    }
  }, {
    key: "fillRect",
    value: function fillRect(x, y, width, height) {
      if (arguments.length < 4) throw new TypeError('Failed to execute \'fillRect\' on \'' + this.constructor.name + '\': 4 arguments required, but only ' + arguments.length + ' present.');
      var xResult = Number(x);
      var yResult = Number(y);
      var widthResult = Number(width);
      var heightResult = Number(height);
      if (!Number.isFinite(x + y + width + height)) return;
      var event = (0, _createCanvasEvent["default"])('fillRect', getTransformSlice(this), {
        x: xResult,
        y: yResult,
        width: widthResult,
        height: heightResult
      });

      this._events.push(event);

      this._drawCalls.push(event);
    }
  }, {
    key: "fillText",
    value: function fillText(text, x, y, maxWidth) {
      if (arguments.length < 3) throw new TypeError('Failed to execute \'fillText\' on \'' + this.constructor.name + '\': 3 arguments required, but only ' + arguments.length + ' present.');
      var textResult = String(text);
      var xResult = Number(x);
      var yResult = Number(y);
      var maxWidthResult = Number(maxWidth);
      if (arguments.length === 3 && !Number.isFinite(xResult + yResult)) return;
      if (arguments.length > 3 && !Number.isFinite(xResult + yResult + maxWidthResult)) return;
      var event = (0, _createCanvasEvent["default"])('fillText', getTransformSlice(this), {
        text: textResult,
        x: xResult,
        y: yResult,
        maxWidth: arguments.length === 3 ? null : maxWidthResult
      });

      this._events.push(event);

      this._drawCalls.push(event);
    }
  }, {
    key: "getImageData",
    value: function getImageData() {
      return new ImageData(this._canvas.width, this._canvas.height);
    }
  }, {
    key: "getLineDash",
    value: function getLineDash() {
      return this._lineDashStack[this._stackIndex];
    }
  }, {
    key: "getTransform",
    value: function getTransform() {
      return new _DOMMatrix["default"](this._transformStack[this._stackIndex]);
    }
  }, {
    key: "isPointInPath",
    value: function isPointInPath(path, x, y) {
      var fillRule = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'nonzero';
      if (arguments.length < 2) throw new TypeError('Failed to execute \'isPointInPath\' on \'' + this.constructor.name + '\': 2 arguments required, but only ' + arguments.length + ' present.');

      if (!(path instanceof Path2D)) {
        if (arguments.length > 2) {
          fillRule = y;
        }

        y = x;
        x = path;
      }

      if (fillRule !== 'nonzero' && fillRule !== 'evenodd') throw new TypeError('Failed to execute \'isPointInPath\' on \'' + this.constructor.name + '\': The provided value \'' + fillRule + '\' is not a valid enum value of type CanvasFillRule.');
      var event = (0, _createCanvasEvent["default"])('isPointInPath', getTransformSlice(this), {
        x: Number(x),
        y: Number(y),
        fillRule: fillRule,
        path: path instanceof Path2D ? path._path.slice() : this._path.slice()
      });

      this._events.push(event);

      return false; // return false in a mocking environment, unless I can verify a point is actually within the path
    }
  }, {
    key: "isPointInStroke",
    value: function isPointInStroke(path, x, y) {
      if (arguments.length < 2) throw new TypeError('Failed to execute \'isPointInStroke\' on \'' + this.constructor.name + '\': 2 arguments required, but only ' + arguments.length + ' present.');

      if (!(path instanceof Path2D)) {
        y = x;
        x = path;
      }

      var event = (0, _createCanvasEvent["default"])('isPointInPath', getTransformSlice(this), {
        x: Number(x),
        y: Number(y),
        path: path instanceof Path2D ? path._path.slice() : this._path.slice()
      });

      this._events.push(event);

      return false; // return false in a mocking environment, unless I can verify a point is actually within the path
    }
  }, {
    key: "lineTo",
    value: function lineTo(x, y) {
      if (arguments.length < 2) throw new TypeError('Failed to execute \'lineTo\' on \'' + this.constructor.name + '\': 2 arguments required, but only ' + arguments.length + ' present.');
      var xResult = Number(x);
      var yResult = Number(y);
      if (!Number.isFinite(xResult + yResult)) return;
      var event = (0, _createCanvasEvent["default"])('lineTo', getTransformSlice(this), {
        x: xResult,
        y: yResult
      });

      this._events.push(event);

      this._path.push(event);
    }
  }, {
    key: "measureText",
    value: function measureText(text) {
      if (arguments.length < 1) throw new TypeError('Failed to execute \'measureText\' on \'' + this.constructor.name + '\': 1 argument required, but only 0 present.');
      text = text == null ? '' : text;
      text = text.toString();
      var event = (0, _createCanvasEvent["default"])('measureText', getTransformSlice(this), {
        text: text
      });

      this._events.push(event);

      return new _TextMetrics["default"](text);
    }
  }, {
    key: "moveTo",
    value: function moveTo(x, y) {
      if (arguments.length < 2) throw new TypeError('Failed to execute \'moveTo\' on \'' + this.constructor.name + '\': 2 arguments required, but only ' + arguments.length + ' present.');
      var xResult = Number(x);
      var yResult = Number(y);
      if (!Number.isFinite(x + y)) return;
      var event = (0, _createCanvasEvent["default"])('moveTo', getTransformSlice(this), {
        x: xResult,
        y: yResult
      });

      this._events.push(event);

      this._path.push(event);
    }
  }, {
    key: "putImageData",
    value: function putImageData(data, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
      if (arguments.length < 3) throw new TypeError('Failed to execute \'putImageData\' on \'' + this.constructor.name + '\': 3 arguments required, but only ' + arguments.length + ' present.');
      if (arguments.length > 3 && arguments.length < 7) throw new TypeError('Failed to execute \'putImageData\' on \'' + this.constructor.name + '\': Valid arities are: [3, 7], but ' + arguments.length + ' arguments provided.');
      if (!(data instanceof ImageData)) throw new TypeError('Failed to execute \'putImageData\' on \'' + this.constructor.name + '\': parameter 1 is not of type \'ImageData\'.');
      var xResult = Number(x);
      var yResult = Number(y);
      var dirtyXResult = Number(dirtyX);
      var dirtyYResult = Number(dirtyY);
      var dirtyWidthResult = Number(dirtyWidth);
      var dirtyHeightResult = Number(dirtyHeight);

      if (arguments.length === 3) {
        if (!Number.isFinite(xResult + yResult)) return;
      } else {
        if (!Number.isFinite(xResult + yResult + dirtyXResult + dirtyYResult + dirtyWidthResult + dirtyHeightResult)) return;
      }

      var event = (0, _createCanvasEvent["default"])('putImageData', getTransformSlice(this), {
        x: xResult,
        y: yResult,
        dirtyX: dirtyXResult,
        dirtyY: dirtyYResult,
        dirtyWidth: dirtyWidthResult,
        dirtyHeight: dirtyHeightResult
      });

      this._events.push(event);
    }
  }, {
    key: "quadraticCurveTo",
    value: function quadraticCurveTo(cpx, cpy, x, y) {
      if (arguments.length < 4) throw new TypeError('Failed to execute \'quadraticCurveTo\' on \'' + this.constructor.name + '\': 4 arguments required, but only ' + arguments.length + ' present.');
      var cpxResult = Number(cpx);
      var cpyResult = Number(cpy);
      var xResult = Number(x);
      var yResult = Number(y);
      if (!Number.isFinite(cpxResult + cpyResult + xResult + yResult)) return;
      var event = (0, _createCanvasEvent["default"])('quadraticCurveTo', getTransformSlice(this), {
        cpx: cpxResult,
        cpy: cpyResult,
        x: xResult,
        y: yResult
      });

      this._events.push(event);
    }
  }, {
    key: "rect",
    value: function rect(x, y, width, height) {
      if (arguments.length < 4) throw new TypeError('Failed to execute \'rect\' on \'' + this.constructor.name + '\': 4 arguments required, but only ' + arguments.length + ' present.');
      if (!Number.isFinite(x + y + width + height)) return;
      var xResult = Number(x);
      var yResult = Number(y);
      var widthResult = Number(width);
      var heightResult = Number(height);
      var event = (0, _createCanvasEvent["default"])('rect', getTransformSlice(this), {
        x: xResult,
        y: yResult,
        width: widthResult,
        height: heightResult
      });

      this._events.push(event);

      this._path.push(event);
    }
  }, {
    key: "removeHitRegion",
    value: function removeHitRegion(id) {
      if (arguments.length < 1) throw new TypeError('Failed to execute \'removeHitRegion\' on \'' + this.constructor.name + '\': 1 argument required, but only ' + arguments.length + ' present.');
      var event = (0, _createCanvasEvent["default"])('removeHitRegion', getTransformSlice(this), {
        id: id
      });

      this._events.push(event);
    }
  }, {
    key: "resetTransform",
    value: function resetTransform() {
      this._transformStack[this._stackIndex][0] = 1;
      this._transformStack[this._stackIndex][1] = 0;
      this._transformStack[this._stackIndex][2] = 0;
      this._transformStack[this._stackIndex][3] = 1;
      this._transformStack[this._stackIndex][4] = 0;
      this._transformStack[this._stackIndex][5] = 0;
      var event = (0, _createCanvasEvent["default"])('resetTransform', getTransformSlice(this), {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
      });

      this._events.push(event);
    }
  }, {
    key: "restore",
    value: function restore() {
      if (this._stackIndex <= 0) return;

      this._transformStack.pop();

      this._directionStack.pop();

      this._fillStyleStack.pop();

      this._filterStack.pop();

      this._fontStack.pop();

      this._globalAlphaStack.pop();

      this._globalCompositeOperationStack.pop();

      this._imageSmoothingEnabledStack.pop();

      this._imageSmoothingQualityStack.pop();

      this._lineCapStack.pop();

      this._lineDashStack.pop();

      this._lineDashOffsetStack.pop();

      this._lineJoinStack.pop();

      this._lineWidthStack.pop();

      this._miterLimitStack.pop();

      this._shadowBlurStack.pop();

      this._shadowColorStack.pop();

      this._shadowOffsetXStack.pop();

      this._shadowOffsetYStack.pop();

      this._strokeStyleStack.pop();

      this._textAlignStack.pop();

      this._textBaselineStack.pop();

      this._stackIndex -= 1;
      var event = (0, _createCanvasEvent["default"])('restore', getTransformSlice(this), {});

      this._events.push(event);
    }
  }, {
    key: "rotate",
    value: function rotate(angle) {
      if (arguments.length < 1) throw new TypeError('Failed to execute \'rotate\' on \'' + this.constructor.name + '\': 1 argument required, but only 0 present.');
      angle = Number(angle);
      if (!Number.isFinite(angle)) return;
      var a = this._transformStack[this._stackIndex][0];
      var b = this._transformStack[this._stackIndex][1];
      var c = this._transformStack[this._stackIndex][2];
      var d = this._transformStack[this._stackIndex][3];
      var cos = Math.cos(angle);
      var sin = Math.sin(angle);
      this._transformStack[this._stackIndex][0] = a * cos + c * sin;
      this._transformStack[this._stackIndex][1] = b * cos + d * sin;
      this._transformStack[this._stackIndex][2] = c * cos - a * sin;
      this._transformStack[this._stackIndex][3] = d * cos - b * sin;
      var event = (0, _createCanvasEvent["default"])('rotate', getTransformSlice(this), {
        angle: angle
      });

      this._events.push(event);
    }
  }, {
    key: "save",
    value: function save() {
      this._transformStack.push(this._transformStack[this._stackIndex]);

      this._directionStack.push(this._directionStack[this._stackIndex]);

      this._fillStyleStack.push(this._fillStyleStack[this._stackIndex]);

      this._filterStack.push(this._filterStack[this._stackIndex]);

      this._fontStack.push(this._fontStack[this._stackIndex]);

      this._globalAlphaStack.push(this._globalAlphaStack[this._stackIndex]);

      this._globalCompositeOperationStack.push(this._globalCompositeOperationStack[this._stackIndex]);

      this._imageSmoothingEnabledStack.push(this._imageSmoothingEnabledStack[this._stackIndex]);

      this._imageSmoothingQualityStack.push(this._imageSmoothingQualityStack[this._stackIndex]);

      this._lineCapStack.push(this._lineCapStack[this._stackIndex]);

      this._lineDashStack.push(this._lineDashStack[this._stackIndex]);

      this._lineDashOffsetStack.push(this._lineDashOffsetStack[this._stackIndex]);

      this._lineJoinStack.push(this._lineJoinStack[this._stackIndex]);

      this._lineWidthStack.push(this._lineWidthStack[this.stackIndex]);

      this._miterLimitStack.push(this._miterLimitStack[this._stackIndex]);

      this._shadowBlurStack.push(this._shadowBlurStack[this._stackIndex]);

      this._shadowColorStack.push(this._shadowColorStack[this._stackIndex]);

      this._shadowOffsetXStack.push(this._shadowOffsetXStack[this._stackIndex]);

      this._shadowOffsetYStack.push(this._shadowOffsetYStack[this._stackIndex]);

      this._strokeStyleStack.push(this._strokeStyleStack[this._stackIndex]);

      this._textAlignStack.push(this._textAlignStack[this._stackIndex]);

      this._textBaselineStack.push(this._textBaselineStack[this._stackIndex]);

      this._stackIndex += 1;
      var event = (0, _createCanvasEvent["default"])('save', getTransformSlice(this), {});

      this._events.push(event);
    }
  }, {
    key: "scale",
    value: function scale(x, y) {
      if (arguments.length < 2) throw new TypeError('Failed to execute \'scale\' on \'' + this.constructor.name + '\': 2 arguments required, but only ' + arguments.length + ' present.');
      var xResult = Number(x);
      var yResult = Number(y);

      if (Number.isFinite(xResult) && Number.isFinite(yResult)) {
        this._transformStack[this._stackIndex][0] *= xResult;
        this._transformStack[this._stackIndex][1] *= xResult;
        this._transformStack[this._stackIndex][2] *= yResult;
        this._transformStack[this._stackIndex][3] *= yResult;
        var event = (0, _createCanvasEvent["default"])('scale', getTransformSlice(this), {
          x: xResult,
          y: yResult
        });

        this._events.push(event);
      }
    }
  }, {
    key: "scrollPathIntoView",
    value: function scrollPathIntoView(path) {
      if (arguments.length > 0 && path instanceof Path2D) path = path._path.slice();else path = this._path.slice();
      var event = (0, _createCanvasEvent["default"])('scrollPathIntoView', getTransformSlice(this), {
        path: path
      });

      this._events.push(event);
    }
  }, {
    key: "setLineDash",
    value: function setLineDash(lineDash) {
      var isSequence = [Array, Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array].reduce(function (left, right) {
        return left || lineDash instanceof right;
      }, false);
      if (!isSequence) throw new TypeError('Failed to execute \'setLineDash\' on \'' + this.constructor.name + '\': The provided value cannot be converted to a sequence.');
      var result = [];

      for (var i = 0; i < lineDash.length; i++) {
        var value = Number(lineDash[i]);

        if (Number.isFinite(value) && value >= 0) {
          result.push(value);
        } else {
          return;
        }
      }

      result = this._lineDashStack[this._stackIndex] = result.length % 2 === 1 ? result.concat(result) : result;
      var event = (0, _createCanvasEvent["default"])('setLineDash', getTransformSlice(this), {
        value: result.slice()
      });

      this._events.push(event);
    }
  }, {
    key: "setTransform",
    value: function setTransform(a, b, c, d, e, f) {
      if (arguments.length === 0) {
        a = 1;
        b = 0;
        c = 0;
        d = 1;
        e = 0;
        f = 0;
      } else if (arguments.length === 1) {
        if (a instanceof _DOMMatrix["default"]) {
          var transform = a;
          a = transform.a;
          b = transform.b;
          c = transform.c;
          d = transform.d;
          e = transform.e;
          f = transform.f;
        } else {
          throw new TypeError('Failed to execute \'setTransform\' on \'' + this.constructor.name + '\': parameter ' + a + ' (\'transform\') is not an object.');
        }
      } else if (arguments.length < 6) {
        throw new TypeError('Failed to execute \'setTransform\' on \'' + this.constructor.name + '\': Valid arities are: [0, 1, 6], but ' + arguments.length + ' arguments provided.');
      }

      a = Number(a);
      b = Number(b);
      c = Number(c);
      d = Number(d);
      e = Number(e);
      f = Number(f);
      if (!Number.isFinite(a + b + c + d + e + f)) return;
      this._transformStack[this._stackIndex][0] = a;
      this._transformStack[this._stackIndex][1] = b;
      this._transformStack[this._stackIndex][2] = c;
      this._transformStack[this._stackIndex][3] = d;
      this._transformStack[this._stackIndex][4] = e;
      this._transformStack[this._stackIndex][5] = f;
      var event = (0, _createCanvasEvent["default"])('setTransform', getTransformSlice(this), {
        a: a,
        b: b,
        c: c,
        d: d,
        e: e,
        f: f
      });

      this._events.push(event);
    }
  }, {
    key: "stroke",
    value: function stroke(path) {
      if (arguments.length === 0) {
        path = this._path.slice();
      } else {
        if (!(path instanceof Path2D)) throw new TypeError('Failed to execute \'stroke\' on \'' + this.constructor.name + '\': parameter 1 is not of type \'Path2D\'.');
        path = path._path.slice();
      }

      var event = (0, _createCanvasEvent["default"])('stroke', getTransformSlice(this), {
        path: path
      });

      this._events.push(event);

      this._drawCalls.push(event);
    }
  }, {
    key: "strokeRect",
    value: function strokeRect(x, y, width, height) {
      if (arguments.length < 4) throw new TypeError('Failed to execute \'strokeRect\' on \'' + this.constructor.name + '\': 4 arguments required, but only ' + arguments.length + ' present.');
      x = Number(x);
      y = Number(y);
      width = Number(width);
      height = Number(height);
      if (!Number.isFinite(x + y + width + height)) return;
      var event = (0, _createCanvasEvent["default"])('strokeRect', getTransformSlice(this), {
        x: x,
        y: y,
        width: width,
        height: height
      });

      this._events.push(event);

      this._drawCalls.push(event);
    }
  }, {
    key: "strokeText",
    value: function strokeText(text, x, y, maxWidth) {
      if (arguments.length < 3) throw new TypeError('Failed to execute \'strokeText\' on \'' + this.constructor.name + '\': 3 arguments required, but only ' + arguments.length + ' present.');
      var textResult = String(text);
      var xResult = Number(x);
      var yResult = Number(y);
      var maxWidthResult = Number(maxWidth);
      if (arguments.length === 3 && !Number.isFinite(xResult + yResult)) return;
      if (arguments.length > 3 && !Number.isFinite(xResult + yResult + maxWidthResult)) return;
      var event = (0, _createCanvasEvent["default"])('strokeText', getTransformSlice(this), {
        text: textResult,
        x: xResult,
        y: yResult,
        maxWidth: arguments.length === 3 ? null : maxWidthResult
      });

      this._events.push(event);

      this._drawCalls.push(event);
    }
  }, {
    key: "transform",
    value: function transform(a, b, c, d, e, f) {
      if (arguments.length < 6) throw new TypeError('Failed to execute \'transform\' on \'' + this.constructor.name + '\': 6 arguments required, but only ' + arguments.length + ' present.');
      a = Number(a);
      b = Number(b);
      c = Number(c);
      d = Number(d);
      e = Number(e);
      f = Number(f);
      if (!Number.isFinite(a + b + c + d + e + f)) return;
      var sa = this._transformStack[this._stackIndex][0];
      var sb = this._transformStack[this._stackIndex][1];
      var sc = this._transformStack[this._stackIndex][2];
      var sd = this._transformStack[this._stackIndex][3];
      var se = this._transformStack[this._stackIndex][4];
      var sf = this._transformStack[this._stackIndex][5];
      this._transformStack[this._stackIndex][0] = sa * a + sc * b;
      this._transformStack[this._stackIndex][1] = sb * a + sd * b;
      this._transformStack[this._stackIndex][2] = sa * c + sc * d;
      this._transformStack[this._stackIndex][3] = sb * c + sd * d;
      this._transformStack[this._stackIndex][4] = sa * e + sc * f + se;
      this._transformStack[this._stackIndex][5] = sb * e + sd * f + sf;
      var event = (0, _createCanvasEvent["default"])('transform', getTransformSlice(this), {
        a: a,
        b: b,
        c: c,
        d: d,
        e: e,
        f: f
      });

      this._events.push(event);
    }
  }, {
    key: "translate",
    value: function translate(x, y) {
      if (arguments.length < 2) throw new TypeError('Failed to execute \'translate\' on \'' + this.constructor.name + '\': 2 arguments required, but only ' + arguments.length + ' present.');
      var xResult = Number(x);
      var yResult = Number(y);
      var a = this._transformStack[this._stackIndex][0];
      var b = this._transformStack[this._stackIndex][1];
      var c = this._transformStack[this._stackIndex][2];
      var d = this._transformStack[this._stackIndex][3];

      if (Number.isFinite(xResult + yResult)) {
        this._transformStack[this._stackIndex][4] += a * xResult + c * yResult;
        this._transformStack[this._stackIndex][5] += b * xResult + d * yResult;
        var event = (0, _createCanvasEvent["default"])('translate', getTransformSlice(this), {
          x: xResult,
          y: yResult
        });

        this._events.push(event);
      }
    }
  }, {
    key: "canvas",
    get: function get() {
      return this._canvas;
    }
  }, {
    key: "currentTransform",
    set: function set(value) {
      if (value instanceof _DOMMatrix["default"]) {
        this._transformStack[this._stackIndex][0] = value.a;
        this._transformStack[this._stackIndex][1] = value.b;
        this._transformStack[this._stackIndex][2] = value.c;
        this._transformStack[this._stackIndex][3] = value.d;
        this._transformStack[this._stackIndex][4] = value.e;
        this._transformStack[this._stackIndex][5] = value.f;
        var event = (0, _createCanvasEvent["default"])('currentTransform', getTransformSlice(this), {
          a: value.a,
          b: value.b,
          c: value.c,
          d: value.d,
          e: value.e,
          f: value.f
        });

        this._events.push(event);
      }
    },
    get: function get() {
      return new _DOMMatrix["default"](this._transformStack[this._stackIndex]);
    }
  }, {
    key: "direction",
    set: function set(value) {
      if (value === 'rtl' || value === 'ltr' || value === 'inherit') {
        this._directionStack[this._stackIndex] = value;
        var event = (0, _createCanvasEvent["default"])('direction', getTransformSlice(this), {
          value: value
        });

        this._events.push(event);
      }
    },
    get: function get() {
      return this._directionStack[this._stackIndex];
    }
  }, {
    key: "fillStyle",
    set: function set(value) {
      var valid = false;

      if (typeof value === 'string') {
        var result = parseCSSColor(value);

        if (result) {
          valid = true;
          value = this._fillStyleStack[this._stackIndex] = result;
        }
      } else if (value instanceof CanvasGradient || value instanceof _CanvasPattern["default"]) {
        valid = true;
        this._fillStyleStack[this._stackIndex] = value;
      }

      if (valid) {
        var event = (0, _createCanvasEvent["default"])('fillStyle', getTransformSlice(this), {
          value: value
        });

        this._events.push(event);
      }
    },
    get: function get() {
      return this._fillStyleStack[this._stackIndex];
    }
  }, {
    key: "filter",
    set: function set(value) {
      if (value === '') value = 'none';
      value = this._filterStack[this._stackIndex] = typeof value === 'string' ? value : 'none';
      var event = (0, _createCanvasEvent["default"])('filter', getTransformSlice(this), {
        value: value
      });

      this._events.push(event);
    },
    get: function get() {
      return this._filterStack[this._stackIndex];
    }
  }, {
    key: "font",
    set: function set(value) {
      var ex;

      try {
        var result = (0, _cssfontparser["default"])(value);
        value = this._fontStack[this._stackIndex] = result.toString();
        var event = (0, _createCanvasEvent["default"])('font', getTransformSlice(this), {
          value: value
        });

        this._events.push(event);
      } catch (ex) {}
    },
    get: function get() {
      return this._fontStack[this._stackIndex];
    }
  }, {
    key: "globalAlpha",
    set: function set(value) {
      value = Number(value);
      if (!Number.isFinite(value)) return;
      if (value < 0) return;
      if (value > 1) return;
      this._globalAlphaStack[this._stackIndex] = value;
      var event = (0, _createCanvasEvent["default"])('globalAlpha', getTransformSlice(this), {
        value: value
      });

      this._events.push(event);
    },
    get: function get() {
      return this._globalAlphaStack[this._stackIndex];
    }
  }, {
    key: "globalCompositeOperation",
    set: function set(value) {
      if (compositeOperations.indexOf(value) !== -1) {
        this._globalCompositeOperationStack[this._stackIndex] = value;
        var event = (0, _createCanvasEvent["default"])('globalCompositeOperation', getTransformSlice(this), {
          value: value
        });

        this._events.push(event);
      }
    },
    get: function get() {
      return this._globalCompositeOperationStack[this._stackIndex];
    }
  }, {
    key: "imageSmoothingEnabled",
    set: function set(value) {
      value = this._imageSmoothingEnabledStack[this._stackIndex] = Boolean(value);
      var event = (0, _createCanvasEvent["default"])('imageSmoothingEnabled', getTransformSlice(this), {
        value: value
      });

      this._events.push(event);
    },
    get: function get() {
      return this._imageSmoothingEnabledStack[this._stackIndex];
    }
  }, {
    key: "imageSmoothingQuality",
    set: function set(value) {
      if (value === 'high' || value === 'medium' || value === 'low') {
        this._imageSmoothingQualityStack[this._stackIndex] = value;
        var event = (0, _createCanvasEvent["default"])('imageSmoothingQuality', getTransformSlice(this), {
          value: value
        });

        this._events.push(event);
      }
    },
    get: function get() {
      return this._imageSmoothingQualityStack[this._stackIndex];
    }
  }, {
    key: "lineCap",
    set: function set(value) {
      if (value === 'butt' || value === 'round' || value === 'square') {
        this._lineCapStack[this._stackIndex] = value;
        var event = (0, _createCanvasEvent["default"])('lineCap', getTransformSlice(this), {
          value: value
        });

        this._events.push(event);
      }
    },
    get: function get() {
      return this._lineCapStack[this._stackIndex];
    }
  }, {
    key: "lineDashOffset",
    set: function set(value) {
      var result = Number(value);

      if (Number.isFinite(result)) {
        this._lineDashOffsetStack[this._stackIndex] = result;
        var event = (0, _createCanvasEvent["default"])('lineDashOffset', getTransformSlice(this), {
          value: value
        });

        this._events.push(event);
      }
    },
    get: function get() {
      return this._lineDashOffsetStack[this._stackIndex];
    }
  }, {
    key: "lineJoin",
    set: function set(value) {
      if (value === 'round' || value === 'bevel' || value === 'miter') {
        this._lineJoinStack[this._stackIndex] = value;
        var event = (0, _createCanvasEvent["default"])('lineJoin', getTransformSlice(this), {
          value: value
        });

        this._events.push(event);
      }
    },
    get: function get() {
      return this._lineJoinStack[this._stackIndex];
    }
  }, {
    key: "lineWidth",
    set: function set(value) {
      var result = Number(value);

      if (Number.isFinite(result) && result > 0) {
        this._lineWidthStack[this._stackIndex] = result;
        var event = (0, _createCanvasEvent["default"])('lineWidth', getTransformSlice(this), {
          value: result
        });

        this._events.push(event);
      }
    },
    get: function get() {
      return this._lineWidthStack[this._stackIndex];
    }
  }, {
    key: "miterLimit",
    set: function set(value) {
      var result = Number(value);

      if (Number.isFinite(result) && result > 0) {
        this._miterLimitStack[this._stackIndex] = result;
        var event = (0, _createCanvasEvent["default"])('lineWidth', getTransformSlice(this), {
          value: result
        });

        this._events.push(event);
      }
    },
    get: function get() {
      return this._miterLimitStack[this._stackIndex];
    }
  }, {
    key: "shadowBlur",
    set: function set(value) {
      var result = Number(value);

      if (Number.isFinite(result) && result > 0) {
        this._shadowBlurStack[this._stackIndex] = result;
        var event = (0, _createCanvasEvent["default"])('shadowBlur', getTransformSlice(this), {
          value: result
        });

        this._events.push(event);
      }
    },
    get: function get() {
      return this._shadowBlurStack[this._stackIndex];
    }
  }, {
    key: "shadowColor",
    set: function set(value) {
      if (typeof value === 'string') {
        var result = parseCSSColor(value);

        if (result) {
          this._shadowColorStack[this._stackIndex] = result;
          var event = (0, _createCanvasEvent["default"])('shadowColor', getTransformSlice(this), {
            value: result
          });

          this._events.push(event);
        }
      }
    },
    get: function get() {
      return this._shadowColorStack[this._stackIndex];
    }
  }, {
    key: "shadowOffsetX",
    set: function set(value) {
      var result = Number(value);

      if (Number.isFinite(result)) {
        this._shadowOffsetXStack[this._stackIndex] = result;
        var event = (0, _createCanvasEvent["default"])('shadowOffsetX', getTransformSlice(this), {
          value: result
        });

        this._events.push(event);
      }
    },
    get: function get() {
      return this._shadowOffsetXStack[this._stackIndex];
    }
  }, {
    key: "shadowOffsetY",
    set: function set(value) {
      var result = Number(value);

      if (Number.isFinite(result)) {
        this._shadowOffsetXStack[this._stackIndex] = result;
        var event = (0, _createCanvasEvent["default"])('shadowOffsetY', getTransformSlice(this), {
          value: result
        });

        this._events.push(event);
      }
    },
    get: function get() {
      return this._shadowOffsetXStack[this._stackIndex];
    }
  }, {
    key: "strokeStyle",
    set: function set(value) {
      var valid = false;

      if (typeof value === 'string') {
        var result = parseCSSColor(value);

        if (result) {
          valid = true;
          value = this._strokeStyleStack[this._stackIndex] = result;
        }
      } else if (value instanceof CanvasGradient || value instanceof _CanvasPattern["default"]) {
        valid = true;
        this._strokeStyleStack[this._stackIndex] = value;
      }

      if (valid) {
        var event = (0, _createCanvasEvent["default"])('strokeStyle', getTransformSlice(this), {
          value: value
        });

        this._events.push(event);
      }
    },
    get: function get() {
      return this._strokeStyleStack[this._stackIndex];
    }
  }, {
    key: "textAlign",
    set: function set(value) {
      if (value === 'left' || value === 'right' || value === 'center' || value === 'start' || value === 'end') {
        this._textAlignStack[this._stackIndex] = value;
        var event = (0, _createCanvasEvent["default"])('textAlign', getTransformSlice(this), {
          value: value
        });

        this._events.push(event);
      }
    },
    get: function get() {
      return this._textAlignStack[this._stackIndex];
    }
  }, {
    key: "textBaseline",
    set: function set(value) {
      if (value === 'top' || value === 'hanging' || value === 'middle' || value === 'alphabetic' || value === 'ideographic' || value === 'bottom') {
        this._textBaselineStack[this._stackIndex] = value;
        var event = (0, _createCanvasEvent["default"])('textBaseline', getTransformSlice(this), {
          value: value
        });

        this._events.push(event);
      }
    },
    get: function get() {
      return this._textBaselineStack[this._stackIndex];
    }
  }]);

  return CanvasRenderingContext2D;
}();

exports["default"] = CanvasRenderingContext2D;