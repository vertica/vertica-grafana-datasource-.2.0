import { Observable } from 'rxjs';
import { ComponentType } from 'react';
import { GrafanaPlugin, PluginMeta } from './plugin';
import { PanelData } from './panel';
import { LogRowModel } from './logs';
import { AnnotationEvent, AnnotationSupport } from './annotations';
import { DataTopic, KeyValue, LoadingState, TableData, TimeSeries } from './data';
import { DataFrame, DataFrameDTO } from './dataFrame';
import { RawTimeRange, TimeRange } from './time';
import { ScopedVars } from './ScopedVars';
import { CoreApp } from './app';
import { LiveChannelSupport } from './live';
import { CustomVariableSupport, DataSourceVariableSupport, StandardVariableSupport } from './variables';
export interface DataSourcePluginOptionsEditorProps<JSONData = DataSourceJsonData, SecureJSONData = {}> {
    options: DataSourceSettings<JSONData, SecureJSONData>;
    onOptionsChange: (options: DataSourceSettings<JSONData, SecureJSONData>) => void;
}
export declare type DataSourceQueryType<DSType> = DSType extends DataSourceApi<infer TQuery, any> ? TQuery : never;
export declare type DataSourceOptionsType<DSType> = DSType extends DataSourceApi<any, infer TOptions> ? TOptions : never;
export declare class DataSourcePlugin<DSType extends DataSourceApi<TQuery, TOptions>, TQuery extends DataQuery = DataSourceQueryType<DSType>, TOptions extends DataSourceJsonData = DataSourceOptionsType<DSType>, TSecureOptions = {}> extends GrafanaPlugin<DataSourcePluginMeta<TOptions>> {
    DataSourceClass: DataSourceConstructor<DSType, TQuery, TOptions>;
    components: DataSourcePluginComponents<DSType, TQuery, TOptions, TSecureOptions>;
    constructor(DataSourceClass: DataSourceConstructor<DSType, TQuery, TOptions>);
    setConfigEditor(editor: ComponentType<DataSourcePluginOptionsEditorProps<TOptions, TSecureOptions>>): this;
    setConfigCtrl(ConfigCtrl: any): this;
    setQueryCtrl(QueryCtrl: any): this;
    setAnnotationQueryCtrl(AnnotationsQueryCtrl: any): this;
    setQueryEditor(QueryEditor: ComponentType<QueryEditorProps<DSType, TQuery, TOptions>>): this;
    setExploreQueryField(ExploreQueryField: ComponentType<ExploreQueryFieldProps<DSType, TQuery, TOptions>>): this;
    setExploreMetricsQueryField(ExploreQueryField: ComponentType<ExploreQueryFieldProps<DSType, TQuery, TOptions>>): this;
    setExploreLogsQueryField(ExploreQueryField: ComponentType<ExploreQueryFieldProps<DSType, TQuery, TOptions>>): this;
    setQueryEditorHelp(QueryEditorHelp: ComponentType<QueryEditorHelpProps>): this;
    /**
     * @deprecated prefer using `setQueryEditorHelp`
     */
    setExploreStartPage(ExploreStartPage: ComponentType<QueryEditorHelpProps>): this;
    setVariableQueryEditor(VariableQueryEditor: any): this;
    setMetadataInspector(MetadataInspector: ComponentType<MetadataInspectorProps<DSType, TQuery, TOptions>>): this;
    setComponentsFromLegacyExports(pluginExports: any): void;
}
export interface DataSourcePluginMeta<T extends KeyValue = {}> extends PluginMeta<T> {
    builtIn?: boolean;
    metrics?: boolean;
    logs?: boolean;
    annotations?: boolean;
    alerting?: boolean;
    tracing?: boolean;
    mixed?: boolean;
    hasQueryHelp?: boolean;
    category?: string;
    queryOptions?: PluginMetaQueryOptions;
    sort?: number;
    streaming?: boolean;
    unlicensed?: boolean;
}
interface PluginMetaQueryOptions {
    cacheTimeout?: boolean;
    maxDataPoints?: boolean;
    minInterval?: boolean;
}
export interface DataSourcePluginComponents<DSType extends DataSourceApi<TQuery, TOptions>, TQuery extends DataQuery = DataQuery, TOptions extends DataSourceJsonData = DataSourceJsonData, TSecureOptions = {}> {
    QueryCtrl?: any;
    AnnotationsQueryCtrl?: any;
    VariableQueryEditor?: any;
    QueryEditor?: ComponentType<QueryEditorProps<DSType, TQuery, TOptions>>;
    ExploreQueryField?: ComponentType<ExploreQueryFieldProps<DSType, TQuery, TOptions>>;
    ExploreMetricsQueryField?: ComponentType<ExploreQueryFieldProps<DSType, TQuery, TOptions>>;
    ExploreLogsQueryField?: ComponentType<ExploreQueryFieldProps<DSType, TQuery, TOptions>>;
    QueryEditorHelp?: ComponentType<QueryEditorHelpProps>;
    ConfigEditor?: ComponentType<DataSourcePluginOptionsEditorProps<TOptions, TSecureOptions>>;
    MetadataInspector?: ComponentType<MetadataInspectorProps<DSType, TQuery, TOptions>>;
}
export interface DataSourceConstructor<DSType extends DataSourceApi<TQuery, TOptions>, TQuery extends DataQuery = DataQuery, TOptions extends DataSourceJsonData = DataSourceJsonData> {
    new (instanceSettings: DataSourceInstanceSettings<TOptions>, ...args: any[]): DSType;
}
/**
 * The main data source abstraction interface, represents an instance of a data source
 *
 * Although this is a class, datasource implementations do not *yet* need to extend it.
 * As such, we can not yet add functions with default implementations.
 */
export declare abstract class DataSourceApi<TQuery extends DataQuery = DataQuery, TOptions extends DataSourceJsonData = DataSourceJsonData> {
    /**
     *  Set in constructor
     */
    readonly name: string;
    /**
     *  Set in constructor
     */
    readonly id: number;
    /**
     *  Set in constructor
     */
    readonly type: string;
    /**
     *  min interval range
     */
    interval?: string;
    constructor(instanceSettings: DataSourceInstanceSettings<TOptions>);
    /**
     * Imports queries from a different datasource
     */
    importQueries?(queries: TQuery[], originMeta: PluginMeta): Promise<TQuery[]>;
    /**
     * Initializes a datasource after instantiation
     */
    init?: () => void;
    /**
     * Query for data, and optionally stream results
     */
    abstract query(request: DataQueryRequest<TQuery>): Promise<DataQueryResponse> | Observable<DataQueryResponse>;
    /**
     * Test & verify datasource settings & connection details
     */
    abstract testDatasource(): Promise<any>;
    /**
     *  Get hints for query improvements
     */
    getQueryHints?(query: TQuery, results: any[], ...rest: any): QueryHint[];
    /**
     * Convert a query to a simple text string
     */
    getQueryDisplayText?(query: TQuery): string;
    /**
     * Retrieve context for a given log row
     */
    getLogRowContext?: <TContextQueryOptions extends {}>(row: LogRowModel, options?: TContextQueryOptions) => Promise<DataQueryResponse>;
    /**
     * Variable query action.
     */
    metricFindQuery?(query: any, options?: any): Promise<MetricFindValue[]>;
    /**
     * Get tag keys for adhoc filters
     */
    getTagKeys?(options?: any): Promise<MetricFindValue[]>;
    /**
     * Get tag values for adhoc filters
     */
    getTagValues?(options: any): Promise<MetricFindValue[]>;
    /**
     * Set after constructor call, as the data source instance is the most common thing to pass around
     * we attach the components to this instance for easy access
     */
    components?: DataSourcePluginComponents<DataSourceApi<TQuery, TOptions>, TQuery, TOptions>;
    /**
     * static information about the datasource
     */
    meta: DataSourcePluginMeta;
    /**
     * Used by alerting to check if query contains template variables
     */
    targetContainsTemplate?(query: TQuery): boolean;
    /**
     * Used in explore
     */
    modifyQuery?(query: TQuery, action: QueryFixAction): TQuery;
    /**
     * Used in explore
     */
    getHighlighterExpression?(query: TQuery): string[];
    /**
     * Used in explore
     */
    languageProvider?: any;
    getVersion?(optionalOptions?: any): Promise<string>;
    showContextToggle?(row?: LogRowModel): boolean;
    interpolateVariablesInQueries?(queries: TQuery[], scopedVars: ScopedVars | {}): TQuery[];
    /**
     * An annotation processor allows explicit control for how annotations are managed.
     *
     * It is only necessary to configure an annotation processor if the default behavior is not desirable
     */
    annotations?: AnnotationSupport<TQuery>;
    /**
     * Can be optionally implemented to allow datasource to be a source of annotations for dashboard.
     * This function will only be called if an angular {@link AnnotationsQueryCtrl} is configured and
     * the {@link annotations} is undefined
     *
     * @deprecated -- prefer using {@link AnnotationSupport}
     */
    annotationQuery?(options: AnnotationQueryRequest<TQuery>): Promise<AnnotationEvent[]>;
    /**
     * Define live streaming behavior within this datasource settings
     *
     * Note: `plugin.json` must also define `live: true`
     *
     * @alpha -- experimental
     */
    channelSupport?: LiveChannelSupport;
    /**
     * Defines new variable support
     * @alpha -- experimental
     */
    variables?: StandardVariableSupport<DataSourceApi<TQuery, TOptions>> | CustomVariableSupport<DataSourceApi<TQuery, TOptions>> | DataSourceVariableSupport<DataSourceApi<TQuery, TOptions>>;
}
export interface MetadataInspectorProps<DSType extends DataSourceApi<TQuery, TOptions>, TQuery extends DataQuery = DataQuery, TOptions extends DataSourceJsonData = DataSourceJsonData> {
    datasource: DSType;
    data: DataFrame[];
}
export interface QueryEditorProps<DSType extends DataSourceApi<TQuery, TOptions>, TQuery extends DataQuery = DataQuery, TOptions extends DataSourceJsonData = DataSourceJsonData, TVQuery extends DataQuery = TQuery> {
    datasource: DSType;
    query: TVQuery;
    onRunQuery: () => void;
    onChange: (value: TVQuery) => void;
    onBlur?: () => void;
    /**
     * Contains query response filtered by refId of QueryResultBase and possible query error
     */
    data?: PanelData;
    range?: TimeRange;
    exploreId?: any;
    history?: HistoryItem[];
    queries?: DataQuery[];
}
export declare enum ExploreMode {
    Logs = "Logs",
    Metrics = "Metrics",
    Tracing = "Tracing"
}
export interface ExploreQueryFieldProps<DSType extends DataSourceApi<TQuery, TOptions>, TQuery extends DataQuery = DataQuery, TOptions extends DataSourceJsonData = DataSourceJsonData> extends QueryEditorProps<DSType, TQuery, TOptions> {
    history: any[];
    onBlur?: () => void;
    exploreId?: any;
}
export interface QueryEditorHelpProps {
    datasource: DataSourceApi;
    onClickExample: (query: DataQuery) => void;
    exploreId?: any;
}
/**
 * Starting in v6.2 DataFrame can represent both TimeSeries and TableData
 */
export declare type LegacyResponseData = TimeSeries | TableData | any;
export declare type DataQueryResponseData = DataFrame | DataFrameDTO | LegacyResponseData;
export interface DataQueryResponse {
    /**
     * The response data.  When streaming, this may be empty
     * or a partial result set
     */
    data: DataQueryResponseData[];
    /**
     * When returning multiple partial responses or streams
     * Use this key to inform Grafana how to combine the partial responses
     * Multiple responses with same key are replaced (latest used)
     */
    key?: string;
    /**
     * Optionally include error info along with the response data
     */
    error?: DataQueryError;
    /**
     * Use this to control which state the response should have
     * Defaults to LoadingState.Done if state is not defined
     */
    state?: LoadingState;
}
/**
 * These are the common properties available to all queries in all datasources
 * Specific implementations will extend this interface adding the required properties
 * for the given context
 */
export interface DataQuery {
    /**
     * A - Z
     */
    refId: string;
    /**
     * true if query is disabled (ie should not be returned to the dashboard)
     */
    hide?: boolean;
    /**
     * Unique, guid like, string used in explore mode
     */
    key?: string;
    /**
     * Specify the query flavor
     */
    queryType?: string;
    /**
     * The data topic results should be attached to
     */
    dataTopic?: DataTopic;
    /**
     * For mixed data sources the selected datasource is on the query level.
     * For non mixed scenarios this is undefined.
     */
    datasource?: string | null;
}
export declare enum DataQueryErrorType {
    Cancelled = "cancelled",
    Timeout = "timeout",
    Unknown = "unknown"
}
export interface DataQueryError {
    data?: {
        message?: string;
        error?: string;
    };
    message?: string;
    status?: string;
    statusText?: string;
    refId?: string;
    type?: DataQueryErrorType;
}
export interface DataQueryRequest<TQuery extends DataQuery = DataQuery> {
    requestId: string;
    interval: string;
    intervalMs: number;
    maxDataPoints?: number;
    range: TimeRange;
    reverse?: boolean;
    scopedVars: ScopedVars;
    targets: TQuery[];
    timezone: string;
    app: CoreApp | string;
    cacheTimeout?: string;
    exploreMode?: ExploreMode;
    rangeRaw?: RawTimeRange;
    timeInfo?: string;
    panelId?: number;
    dashboardId?: number;
    startTime: number;
    endTime?: number;
    liveStreaming?: boolean;
    /**
     * @deprecated showingGraph and showingTable are always set to true
     */
    showingGraph?: boolean;
    showingTable?: boolean;
}
export interface DataQueryTimings {
    dataProcessingTime: number;
}
export interface QueryFix {
    label: string;
    action?: QueryFixAction;
}
export interface QueryFixAction {
    type: string;
    query?: string;
    preventSubmit?: boolean;
}
export interface QueryHint {
    type: string;
    label: string;
    fix?: QueryFix;
}
export interface MetricFindValue {
    text: string;
    value?: string | number;
    expandable?: boolean;
}
export interface DataSourceJsonData {
    authType?: string;
    defaultRegion?: string;
    profile?: string;
}
/**
 * Data Source instance edit model.  This is returned from:
 *  /api/datasources
 */
export interface DataSourceSettings<T extends DataSourceJsonData = DataSourceJsonData, S = {}> {
    id: number;
    orgId: number;
    name: string;
    typeLogoUrl: string;
    type: string;
    access: string;
    url: string;
    password: string;
    user: string;
    database: string;
    basicAuth: boolean;
    basicAuthPassword: string;
    basicAuthUser: string;
    isDefault: boolean;
    jsonData: T;
    secureJsonData?: S;
    secureJsonFields: KeyValue<boolean>;
    readOnly: boolean;
    withCredentials: boolean;
    version?: number;
}
/**
 * Frontend settings model that is passed to Datasource constructor. This differs a bit from the model above
 * as this data model is available to every user who has access to a data source (Viewers+).  This is loaded
 * in bootData (on page load), or from: /api/frontend/settings
 */
export interface DataSourceInstanceSettings<T extends DataSourceJsonData = DataSourceJsonData> {
    id: number;
    uid: string;
    type: string;
    name: string;
    meta: DataSourcePluginMeta;
    url?: string;
    jsonData: T;
    username?: string;
    password?: string;
    database?: string;
    isDefault?: boolean;
    /**
     * This is the full Authorization header if basic auth is enabled.
     * Only available here when access is Browser (direct), when access is Server (proxy)
     * The basic auth header, username & password is never exposed to browser/Frontend
     * so this will be empty then.
     */
    basicAuth?: string;
    withCredentials?: boolean;
}
export interface DataSourceSelectItem {
    name: string;
    value: string | null;
    meta: DataSourcePluginMeta;
}
/**
 * Options passed to the datasource.annotationQuery method. See docs/plugins/developing/datasource.md
 *
 * @deprecated -- use {@link AnnotationSupport}
 */
export interface AnnotationQueryRequest<MoreOptions = {}> {
    range: TimeRange;
    rangeRaw: RawTimeRange;
    dashboard: any;
    annotation: {
        datasource: string;
        enable: boolean;
        name: string;
    } & MoreOptions;
}
export interface HistoryItem<TQuery extends DataQuery = DataQuery> {
    ts: number;
    query: TQuery;
}
export declare abstract class LanguageProvider {
    abstract datasource: DataSourceApi<any, any>;
    abstract request: (url: string, params?: any) => Promise<any>;
    /**
     * Returns startTask that resolves with a task list when main syntax is loaded.
     * Task list consists of secondary promises that load more detailed language features.
     */
    abstract start: () => Promise<Array<Promise<any>>>;
    startTask?: Promise<any[]>;
}
export {};
